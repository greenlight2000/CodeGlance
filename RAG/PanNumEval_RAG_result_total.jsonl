[
  {
    "ID": "0",
    "matches": [
      {
        "query": "pandas.notnull",
        "results": [
          {
            "api_path": "pandas.notnull",
            "api_name": "notnull",
            "api_signature": "(self) -> 'KnowledgeFrame'",
            "api_description": "Detect existing (non-missing) values.",
            "api_source": [
              "def notna(obj: object) -> bool | npt.NDArray[np.bool_] | NDFrame:\n",
              "    res = isna(obj)\n",
              "    if isinstance(res, bool):\n",
              "        return not res\n",
              "    return ~res\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "1",
    "matches": [
      {
        "query": "numpy.zeros",
        "results": [
          {
            "api_path": "numpy.zeros",
            "api_name": "zeros",
            "api_signature": "(shape, dtype=None, order='C', ctx=None)",
            "api_description": "Return a new array of given shape and type, filled with zeros.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.zeros(5)\n    array([0., 0., 0., 0., 0.])\n\n    >>> np.zeros((5,), dtype=int)\n    array([0, 0, 0, 0, 0], dtype=int64)\n\n    >>> np.zeros((2, 1))\n    array([[0.],\n           [0.]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "2",
    "matches": [
      {
        "query": "numpy.arange",
        "results": [
          {
            "api_path": "numpy.arange",
            "api_name": "arange",
            "api_signature": "(*args, **params)",
            "api_description": "arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.arange(3)\n    array([0., 1., 2.])\n\n    >>> np.arange(3.0)\n    array([0., 1., 2.])\n\n    >>> np.arange(3,7)\n    array([3., 4., 5., 6.])\n\n    >>> np.arange(3,7,2)\n    array([3., 5.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "3",
    "matches": [
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "numpy.concatenate",
        "results": [
          {
            "api_path": "numpy.concatenate",
            "api_name": "concatenate",
            "api_signature": "(numsets, axis=0)",
            "api_description": "Return a numset concatenated with given numsets along the specified axis.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])\n\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1., 2., 5.],\n           [3., 4., 6.]])\n\n    >>> np.concatenate((a, b), axis=None)\n    array([1., 2., 3., 4., 5., 6.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "4",
    "matches": [
      {
        "query": "pandas.Series",
        "results": [
          {
            "api_path": "pandas.Series",
            "api_name": "Series",
            "api_signature": "(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False)",
            "api_description": "ndarray with axis labels in one-dimension (also time collections).",
            "api_source": [
              "class Series(base.IndexOpsMixin, NDFrame):  # type: ignore[misc]\n",
              "\n",
              "    _typ = \"series\"\n",
              "    _HANDLED_TYPES = (Index, ExtensionArray, np.ndarray)\n",
              "\n",
              "    _name: Hashable\n",
              "    _metadata: list[str] = [\"_name\"]\n",
              "    _internal_names_set = {\"index\", \"name\"} | NDFrame._internal_names_set\n",
              "    _accessors = {\"dt\", \"cat\", \"str\", \"sparse\"}\n",
              "    _hidden_attrs = (\n",
              "        base.IndexOpsMixin._hidden_attrs | NDFrame._hidden_attrs | frozenset([])\n",
              "    )\n",
              "\n",
              "    # similar to __array_priority__, positions Series after DataFrame\n",
              "    #  but before Index and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 3000\n",
              "\n",
              "    # Override cache_readonly bc Series is mutable\n",
              "    # error: Incompatible types in assignment (expression has type \"property\",\n",
              "    # base class \"IndexOpsMixin\" defined the type as \"Callable[[IndexOpsMixin], bool]\")\n",
              "    hasnans = property(  # type: ignore[assignment]\n",
              "        # error: \"Callable[[IndexOpsMixin], bool]\" has no attribute \"fget\"\n",
              "        base.IndexOpsMixin.hasnans.fget,  # type: ignore[attr-defined]\n",
              "        doc=base.IndexOpsMixin.hasnans.__doc__,\n",
              "    )\n",
              "    _mgr: SingleManager\n",
              "\n",
              "    # ----------------------------------------------------------------------\n",
              "    # Constructors\n",
              "\n",
              "    def __init__(\n",
              "        self,\n",
              "        data=None,\n",
              "        index=None,\n",
              "        dtype: Dtype | None = None,\n",
              "        name=None,\n",
              "        copy: bool | None = None,\n",
              "        fastpath: bool | lib.NoDefault = lib.no_default,\n",
              "    ) -> None:\n",
              "        if fastpath is not lib.no_default:\n",
              "            warnings.warn(\n",
              "                \"The 'fastpath' keyword in pd.Series is deprecated and will \"\n",
              "                \"be removed in a future version.\",\n",
              "                DeprecationWarning,\n",
              "                stacklevel=find_stack_level(),\n",
              "            )\n",
              "        else:\n",
              "            fastpath = False\n",
              "\n",
              "        allow_mgr = False\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "pandas.concat",
        "results": [
          {
            "api_path": "pandas.concat",
            "api_name": "concat",
            "api_signature": "(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion'",
            "api_description": "Concatenate monkey objects along one axis, using set logic on the other axes if needed.",
            "api_source": [
              "def concat(\n",
              "    if copy is None:\n",
              "        if using_copy_on_write():\n",
              "            copy = False\n",
              "        else:\n",
              "            copy = True\n",
              "    elif copy and using_copy_on_write():\n",
              "        copy = False\n",
              "\n",
              "    op = _Concatenator(\n",
              "        objs,\n",
              "        axis=axis,\n",
              "        ignore_index=ignore_index,\n",
              "        join=join,\n",
              "        keys=keys,\n",
              "        levels=levels,\n",
              "        names=names,\n",
              "        verify_integrity=verify_integrity,\n",
              "        copy=copy,\n",
              "        sort=sort,\n",
              "    )\n",
              "\n",
              "    return op.get_result()\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "5",
    "matches": [
      {
        "query": "numpy.dot",
        "results": [
          {
            "api_path": "numpy.dot",
            "api_name": "dot",
            "api_signature": NaN,
            "api_description": "Dot product of two arrays.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array(3)\n    >>> b = np.array(4)\n    >>> np.dot(a, b)\n    array(12.)\n\n    For 2-D arrays it is the matrix product:\n\n    >>> a = np.array([[1, 0], [0, 1]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.dot(a, b)\n    array([[4., 1.],\n           [2., 2.]])\n\n    >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))\n    >>> b = np.arange(5*6)[::-1].reshape((6,5))\n    >>> np.dot(a, b)[2,3,2,2]\n    array(29884.)\n    >>> np.sum(a[2,3,2,:] * b[:,2])\n    array(29884.)"
          }
        ]
      },
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "pandas.merge",
        "results": [
          {
            "api_path": "pandas.merge",
            "api_name": "merge",
            "api_signature": "(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame'",
            "api_description": "Database-style join the named Collections objects or KnowledgeFrame.",
            "api_source": [
              "@Substitution(\"\\nleft : DataFrame or named Series\")\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "6",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "7",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "8",
    "matches": [
      {
        "query": "numpy.split",
        "results": [
          {
            "api_path": "numpy.split",
            "api_name": "split",
            "api_signature": "(sep=None, get_maxsep_split=-1)",
            "api_description": "Return words of the input string using the specified delimiter.",
            "api_source": [
              "@array_function_dispatch(_split_dispatcher)\n",
              "    try:\n",
              "        len(indices_or_sections)\n",
              "    except TypeError:\n",
              "        sections = indices_or_sections\n",
              "        N = ary.shape[axis]\n",
              "        if N % sections:\n",
              "            raise ValueError(\n",
              "                'array split does not result in an equal division') from None\n",
              "    return array_split(ary, indices_or_sections, axis)\n"
            ],
            "api_examples": "\n>>> x = np.arange(9.0)\n    >>> np.split(x, 3)\n    [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7., 8.])]\n\n    >>> np.split(x, [3, 5, 6, 8])\n    [array([0., 1., 2.]), array([3., 4.]), array([5.]), array([6., 7.]), array([])]"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "9",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.tile",
        "results": [
          {
            "api_path": "numpy.tile",
            "api_name": "tile",
            "api_signature": "(A, reps)",
            "api_description": "Construct an array by repeating A the number of times given by reps.",
            "api_source": [
              "@array_function_dispatch(_tile_dispatcher)\n",
              "    try:\n",
              "        tup = tuple(reps)\n",
              "    except TypeError:\n",
              "        tup = (reps,)\n",
              "    d = len(tup)\n",
              "    if all(x == 1 for x in tup) and isinstance(A, _nx.ndarray):\n",
              "        # Fixes the problem that the function does not make a copy if A is a\n",
              "        # numpy array and the repetitions are 1 in all dimensions\n",
              "        return _nx.array(A, copy=True, subok=True, ndmin=d)\n",
              "    else:\n",
              "        # Note that no copy of zero-sized arrays is made. However since they\n",
              "        # have no data there is no risk of an inadvertent overwrite.\n",
              "        c = _nx.array(A, copy=False, subok=True, ndmin=d)\n",
              "    if (d < c.ndim):\n",
              "        tup = (1,)*(c.ndim-d) + tup\n",
              "    shape_out = tuple(s*t for s, t in zip(c.shape, tup))\n",
              "    n = c.size\n",
              "    if n > 0:\n",
              "        for dim_in, nrep in zip(c.shape, tup):\n",
              "            if nrep != 1:\n",
              "                c = c.reshape(-1, n).repeat(nrep, 0)\n",
              "            n //= dim_in\n",
              "    return c.reshape(shape_out)\n"
            ],
            "api_examples": "\n>>> a = np.array([0, 1, 2])\n    >>> np.tile(a, 2)\n    array([0., 1., 2., 0., 1., 2.])\n    >>> np.tile(a, (2, 2))\n    array([[0., 1., 2., 0., 1., 2.],\n           [0., 1., 2., 0., 1., 2.]])\n    >>> np.tile(a, (2, 1, 2))\n    array([[[0., 1., 2., 0., 1., 2.]],\n           [[0., 1., 2., 0., 1., 2.]]])\n\n    >>> b = np.array([[1, 2], [3, 4]])\n    >>> np.tile(b, 2)\n    array([[1., 2., 1., 2.],\n           [3., 4., 3., 4.]])\n    >>> np.(b, (2, 1))\n    array([[1., 2.],\n           [3., 4.],\n           [1., 2.],\n           [3., 4.]])\n\n    >>> c = np.array([1,2,3,4])\n    >>> np.tile(c,(4,1))\n    array([[1., 2., 3., 4.],\n           [1., 2., 3., 4.],\n           [1., 2., 3., 4.],\n           [1., 2., 3., 4.]])\n\n    Scalar as input:\n\n    >>> np.tile(2, 3)\n    array([2, 2, 2]) # repeating integer `2`"
          }
        ]
      }
    ]
  },
  {
    "ID": "10",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.repeat",
        "results": [
          {
            "api_path": "numpy.repeat",
            "api_name": "repeat",
            "api_signature": "(self, duplicates, axis=None)",
            "api_description": "Return the numset with specified duplicates.",
            "api_source": [
              "@array_function_dispatch(_repeat_dispatcher)\n",
              "    return _wrapfunc(a, 'repeat', repeats, axis=axis)\n"
            ],
            "api_examples": "\n>>> x = np.arange(4).reshape(2, 2)\n    >>> x\n    array([[0., 1.],\n           [2., 3.]])\n    >>> np.repeat(x, repeats=3)\n    array([0., 0., 0., 1., 1., 1., 2., 2., 2., 3., 3., 3.])\n    >>> np.repeat(x, repeats=3, axis=0)\n    array([[0., 1.],\n           [0., 1.],\n           [0., 1.],\n           [2., 3.],\n           [2., 3.],\n           [2., 3.]])\n    >>> np.repeat(x, repeats=3, axis=1)\n    array([[0., 0., 0., 1., 1., 1.],\n           [2., 2., 2., 3., 3., 3.]])"
          }
        ]
      }
    ]
  },
  {
    "ID": "11",
    "matches": [
      {
        "query": "pandas.concat",
        "results": [
          {
            "api_path": "pandas.concat",
            "api_name": "concat",
            "api_signature": "(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion'",
            "api_description": "Concatenate monkey objects along one axis, using set logic on the other axes if needed.",
            "api_source": [
              "def concat(\n",
              "    if copy is None:\n",
              "        if using_copy_on_write():\n",
              "            copy = False\n",
              "        else:\n",
              "            copy = True\n",
              "    elif copy and using_copy_on_write():\n",
              "        copy = False\n",
              "\n",
              "    op = _Concatenator(\n",
              "        objs,\n",
              "        axis=axis,\n",
              "        ignore_index=ignore_index,\n",
              "        join=join,\n",
              "        keys=keys,\n",
              "        levels=levels,\n",
              "        names=names,\n",
              "        verify_integrity=verify_integrity,\n",
              "        copy=copy,\n",
              "        sort=sort,\n",
              "    )\n",
              "\n",
              "    return op.get_result()\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "12",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "13",
    "matches": [
      {
        "query": "numpy.argsort",
        "results": [
          {
            "api_path": "numpy.argsort",
            "api_name": "argsort",
            "api_signature": "(a, axis=-1, kind=None, order=None)",
            "api_description": "Returns the indices that would sort an array.",
            "api_source": [
              "@array_function_dispatch(_argsort_dispatcher)\n",
              "    return _wrapfunc(a, 'argsort', axis=axis, kind=kind, order=order)\n"
            ],
            "api_examples": "\nOne dimensional array:\n\n    >>> x = np.array([3, 1, 2])\n    >>> np.argsort(x)\n    array([1, 2, 0])\n\n    Two-dimensional array:\n\n    >>> x = np.array([[0, 3], [2, 2]])\n    >>> x\n    array([[0, 3],\n           [2, 2]])\n    >>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)\n    >>> ind\n    array([[0, 1],\n           [1, 0]])\n    >>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)\n    array([[0, 2],\n           [2, 3]])\n    >>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)\n    >>> ind\n    array([[0, 1],\n           [0, 1]])\n    >>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)\n    array([[0, 3],\n           [2, 2]])\n\n    Indices of the sorted elements of a N-dimensional array:\n\n    >>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)\n    >>> ind\n    (array([0, 1, 1, 0]), array([0, 0, 1, 1]))\n    >>> x[ind]  # same as np.sort(x, axis=None)\n    array([0, 2, 2, 3])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "numpy.abs",
        "results": [
          {
            "api_path": "numpy.abs",
            "api_name": "abs",
            "api_signature": "(self, *args, **kwargs)",
            "api_description": "Return the absolute value of the given number.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> x = np.array([-1.2, 1.2])\n    >>> np.abs(x)\n    array([1.2, 1.2])"
          }
        ]
      },
      {
        "query": "numpy.linalg",
        "results": [
          {
            "api_path": "numpy.linalg",
            "api_name": "linalg",
            "api_signature": NaN,
            "api_description": "Namespace for ops used in imperative programming.",
            "api_source": [
              "\"\"\"\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "14",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.arange",
        "results": [
          {
            "api_path": "numpy.arange",
            "api_name": "arange",
            "api_signature": "(*args, **params)",
            "api_description": "arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.arange(3)\n    array([0., 1., 2.])\n\n    >>> np.arange(3.0)\n    array([0., 1., 2.])\n\n    >>> np.arange(3,7)\n    array([3., 4., 5., 6.])\n\n    >>> np.arange(3,7,2)\n    array([3., 5.])"
          }
        ]
      },
      {
        "query": "numpy.reshape",
        "results": [
          {
            "api_path": "numpy.reshape",
            "api_name": "reshape",
            "api_signature": "(a, newshape, order='C')",
            "api_description": "Changes the shape of a numset without affecting its data.",
            "api_source": [
              "@array_function_dispatch(_reshape_dispatcher)\n",
              "    return _wrapfunc(a, 'reshape', newshape, order=order)\n"
            ],
            "api_examples": "\n>>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0., 1.],\n           [2., 3.],\n           [4., 5.]])\n\n    >>> np.reshape(a, (2, 3)) # C-like index ordering\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1., 2., 3., 4., 5., 6.])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])"
          }
        ]
      }
    ]
  },
  {
    "ID": "15",
    "matches": [
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "numpy.concatenate",
        "results": [
          {
            "api_path": "numpy.concatenate",
            "api_name": "concatenate",
            "api_signature": "(numsets, axis=0)",
            "api_description": "Return a numset concatenated with given numsets along the specified axis.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])\n\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1., 2., 5.],\n           [3., 4., 6.]])\n\n    >>> np.concatenate((a, b), axis=None)\n    array([1., 2., 3., 4., 5., 6.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "16",
    "matches": [
      {
        "query": "numpy.copyto",
        "results": [
          {
            "api_path": "numpy.copyto",
            "api_name": "copyto",
            "api_signature": NaN,
            "api_description": "Copies values from one array to another, broadcasting as necessary.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "numpy.concatenate",
        "results": [
          {
            "api_path": "numpy.concatenate",
            "api_name": "concatenate",
            "api_signature": "(numsets, axis=0)",
            "api_description": "Return a numset concatenated with given numsets along the specified axis.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])\n\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1., 2., 5.],\n           [3., 4., 6.]])\n\n    >>> np.concatenate((a, b), axis=None)\n    array([1., 2., 3., 4., 5., 6.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "17",
    "matches": [
      {
        "query": "pandas.concat",
        "results": [
          {
            "api_path": "pandas.concat",
            "api_name": "concat",
            "api_signature": "(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion'",
            "api_description": "Concatenate monkey objects along one axis, using set logic on the other axes if needed.",
            "api_source": [
              "def concat(\n",
              "    if copy is None:\n",
              "        if using_copy_on_write():\n",
              "            copy = False\n",
              "        else:\n",
              "            copy = True\n",
              "    elif copy and using_copy_on_write():\n",
              "        copy = False\n",
              "\n",
              "    op = _Concatenator(\n",
              "        objs,\n",
              "        axis=axis,\n",
              "        ignore_index=ignore_index,\n",
              "        join=join,\n",
              "        keys=keys,\n",
              "        levels=levels,\n",
              "        names=names,\n",
              "        verify_integrity=verify_integrity,\n",
              "        copy=copy,\n",
              "        sort=sort,\n",
              "    )\n",
              "\n",
              "    return op.get_result()\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.array_split",
        "results": [
          {
            "api_path": "numpy.array_split",
            "api_name": "array_split",
            "api_signature": "(ary, indices_or_sections, axis=0)",
            "api_description": "Divide a numset into several sub-numsets.",
            "api_source": [
              "@array_function_dispatch(_array_split_dispatcher)\n",
              "    try:\n",
              "        Ntotal = ary.shape[axis]\n",
              "    except AttributeError:\n",
              "        Ntotal = len(ary)\n",
              "    try:\n",
              "        # handle array case.\n",
              "        Nsections = len(indices_or_sections) + 1\n",
              "        div_points = [0] + list(indices_or_sections) + [Ntotal]\n",
              "    except TypeError:\n",
              "        # indices_or_sections is a scalar, not an array.\n",
              "        Nsections = int(indices_or_sections)\n",
              "        if Nsections <= 0:\n",
              "            raise ValueError('number sections must be larger than 0.') from None\n",
              "        Neach_section, extras = divmod(Ntotal, Nsections)\n",
              "        section_sizes = ([0] +\n",
              "                         extras * [Neach_section+1] +\n",
              "                         (Nsections-extras) * [Neach_section])\n",
              "        div_points = _nx.array(section_sizes, dtype=_nx.intp).cumsum()\n",
              "\n",
              "    sub_arys = []\n",
              "    sary = _nx.swapaxes(ary, axis, 0)\n",
              "    for i in range(Nsections):\n",
              "        st = div_points[i]\n",
              "        end = div_points[i + 1]\n",
              "        sub_arys.append(_nx.swapaxes(sary[st:end], axis, 0))\n",
              "\n",
              "    return sub_arys\n"
            ],
            "api_examples": "\n>>> x = np.arange(9.0)\n    >>> np.array_split(x, 3)\n    [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7., 8.])]\n\n    >>> np.array_split(x, [3, 5, 6, 8])\n    [array([0., 1., 2.]), array([3., 4.]), array([5.]), array([6., 7.]), array([])]\n\n    >>> x = np.arange(8.0)\n    >>> np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\n\n    >>> x = np.arange(7.0)\n    >>> np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.]), array([5.,  6.])]"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "18",
    "matches": [
      {
        "query": "numpy.where",
        "results": [
          {
            "api_path": "numpy.where",
            "api_name": "where",
            "api_signature": "(condition, x=None, y=None)",
            "api_description": "filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.arange(10)\n    >>> a\n    array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])\n    >>> np.where(a < 5, a, 10*a)\n    array([ 0.,  1.,  2.,  3.,  4., 50., 60., 70., 80., 90.])\n\n    This can be used on multidimensional arrays too:\n\n    >>> cond = np.array([[True, False], [True, True]])\n    >>> x = np.array([[1, 2], [3, 4]])\n    >>> y = np.array([[9, 8], [7, 6]])\n    >>> np.where(cond, x, y)\n    array([[1., 8.],\n           [3., 4.]])\n\n    The shapes of x, y, and the condition are broadcast together:\n\n    >>> x, y = onp.ogrid[:3, :4]\n    >>> x = np.array(x)\n    >>> y = np.array(y)\n    >>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast\n    array([[10,  0,  0,  0],\n           [10, 11,  1,  1],\n           [10, 11, 12,  2]], dtype=int64)\n\n    >>> a = np.array([[0, 1, 2],\n    ...               [0, 2, 4],\n    ...               [0, 3, 6]])\n    >>> np.where(a < 4, a, -1)  # -1 is broadcast\n    array([[ 0.,  1.,  2.],\n           [ 0.,  2., -1.],\n           [ 0.,  3., -1.]])"
          }
        ]
      },
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "19",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "20",
    "matches": [
      {
        "query": "numpy.arange",
        "results": [
          {
            "api_path": "numpy.arange",
            "api_name": "arange",
            "api_signature": "(*args, **params)",
            "api_description": "arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.arange(3)\n    array([0., 1., 2.])\n\n    >>> np.arange(3.0)\n    array([0., 1., 2.])\n\n    >>> np.arange(3,7)\n    array([3., 4., 5., 6.])\n\n    >>> np.arange(3,7,2)\n    array([3., 5.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "21",
    "matches": [
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "numpy.concatenate",
        "results": [
          {
            "api_path": "numpy.concatenate",
            "api_name": "concatenate",
            "api_signature": "(numsets, axis=0)",
            "api_description": "Return a numset concatenated with given numsets along the specified axis.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])\n\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1., 2., 5.],\n           [3., 4., 6.]])\n\n    >>> np.concatenate((a, b), axis=None)\n    array([1., 2., 3., 4., 5., 6.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "22",
    "matches": [
      {
        "query": "numpy.count_nonzero",
        "results": [
          {
            "api_path": "numpy.count_nonzero",
            "api_name": "count_nonzero",
            "api_signature": "(a, axis=None, *, keepdims=False)",
            "api_description": "Counts the number of non-zero values in the array ``a``.",
            "api_source": [
              "@array_function_dispatch(_count_nonzero_dispatcher)\n",
              "    if axis is None and not keepdims:\n",
              "        return multiarray.count_nonzero(a)\n",
              "\n",
              "    a = asanyarray(a)\n",
              "\n",
              "    # TODO: this works around .astype(bool) not working properly (gh-9847)\n",
              "    if np.issubdtype(a.dtype, np.character):\n",
              "        a_bool = a != a.dtype.type()\n",
              "    else:\n",
              "        a_bool = a.astype(np.bool_, copy=False)\n",
              "\n",
              "    return a_bool.sum(axis=axis, dtype=np.intp, keepdims=keepdims)\n"
            ],
            "api_examples": "\n>>> np.count_nonzero(np.eye(4))\n    4\n    >>> a = np.array([[0, 1, 7, 0],\n    ...               [3, 0, 2, 19]])\n    >>> np.count_nonzero(a)\n    5\n    >>> np.count_nonzero(a, axis=0)\n    array([1, 1, 2, 1])\n    >>> np.count_nonzero(a, axis=1)\n    array([2, 3])\n    >>> np.count_nonzero(a, axis=1, keepdims=True)\n    array([[2],\n           [3]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "23",
    "matches": [
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "24",
    "matches": [
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.vectorize",
        "results": [
          {
            "api_path": "numpy.vectorize",
            "api_name": "vectorize",
            "api_signature": "(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None)",
            "api_description": "vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "25",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "26",
    "matches": [
      {
        "query": "pandas.concat",
        "results": [
          {
            "api_path": "pandas.concat",
            "api_name": "concat",
            "api_signature": "(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion'",
            "api_description": "Concatenate monkey objects along one axis, using set logic on the other axes if needed.",
            "api_source": [
              "def concat(\n",
              "    if copy is None:\n",
              "        if using_copy_on_write():\n",
              "            copy = False\n",
              "        else:\n",
              "            copy = True\n",
              "    elif copy and using_copy_on_write():\n",
              "        copy = False\n",
              "\n",
              "    op = _Concatenator(\n",
              "        objs,\n",
              "        axis=axis,\n",
              "        ignore_index=ignore_index,\n",
              "        join=join,\n",
              "        keys=keys,\n",
              "        levels=levels,\n",
              "        names=names,\n",
              "        verify_integrity=verify_integrity,\n",
              "        copy=copy,\n",
              "        sort=sort,\n",
              "    )\n",
              "\n",
              "    return op.get_result()\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "27",
    "matches": [
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "numpy.add",
        "results": [
          {
            "api_path": "numpy.add",
            "api_name": "add",
            "api_signature": "(x1, x2)",
            "api_description": "Return the two numsets' element-wise string or unicode concatenation.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.add(1.0, 4.0)\n    5.0\n    >>>\n    >>> x1 = np.arange(9.0).reshape((3, 3))\n    >>> x2 = np.arange(3.0)\n    >>> np.add(x1, x2)\n    array([[ 0.,  2.,  4.],\n           [ 3.,  5.,  7.],\n           [ 6.,  8., 10.]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "28",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "29",
    "matches": [
      {
        "query": "numpy.multiply",
        "results": [
          {
            "api_path": "numpy.multiply",
            "api_name": "multiply",
            "api_signature": "(x1, x2, out=None, **kwargs)",
            "api_description": "Multiply arguments element-wise.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.multiply(2.0, 4.0)\n    8.0\n    >>> x1 = np.arange(9.0).reshape((3, 3))\n    >>> x2 = np.arange(3.0)\n    >>> np.multiply(x1, x2)\n    array([[ 0.,  1.,  4.],\n           [ 0.,  4., 10.],\n           [ 0.,  7., 16.]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "30",
    "matches": [
      {
        "query": "numpy.cumsum",
        "results": [
          {
            "api_path": "numpy.cumsum",
            "api_name": "cumsum",
            "api_signature": "(a, axis=None, dtype=None, out=None)",
            "api_description": "Return the elements' total sum along the specified axis.",
            "api_source": [
              "@array_function_dispatch(_cumsum_dispatcher)\n",
              "    return _wrapfunc(a, 'cumsum', axis=axis, dtype=dtype, out=out)\n"
            ],
            "api_examples": "\n>>> a = np.array([[1,2,3], [4,5,6]])\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.cumsum(a)\n    array([ 1,  3,  6, 10, 15, 21])\n    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)\n    array([  1.,   3.,   6.,  10.,  15.,  21.])\n    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\n    array([[1, 2, 3],\n           [5, 7, 9]])\n    >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\n    array([[ 1,  3,  6],\n           [ 4,  9, 15]])"
          }
        ]
      },
      {
        "query": "numpy.array",
        "results": [
          {
            "api_path": "numpy.array",
            "api_name": "array",
            "api_signature": "(obj, itemsize=None, copy=True, unicode=None, order=None)",
            "api_description": "Return a `numset`.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.array([1, 2, 3])\n    array([1., 2., 3.])\n\n    >>> np.array([[1, 2], [3, 4]])\n    array([[1., 2.],\n           [3., 4.]])\n\n    >>> np.array([[1, 0], [0, 1]], dtype=bool)\n    array([[ True, False],\n           [False,  True]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "31",
    "matches": [
      {
        "query": "numpy.histogram",
        "results": [
          {
            "api_path": "numpy.histogram",
            "api_name": "histogram",
            "api_signature": "(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None)",
            "api_description": "Return a dataset's histgram object.",
            "api_source": [
              "@array_function_dispatch(_histogram_dispatcher)\n"
            ],
            "api_examples": "\n>>> np.histogram(np.arange(4), bins=np.arange(5))\n    [array([1, 1, 1, 1], dtype=int64), array([0., 1., 2., 3., 4.])]"
          }
        ]
      },
      {
        "query": "numpy.arange",
        "results": [
          {
            "api_path": "numpy.arange",
            "api_name": "arange",
            "api_signature": "(*args, **params)",
            "api_description": "arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.arange(3)\n    array([0., 1., 2.])\n\n    >>> np.arange(3.0)\n    array([0., 1., 2.])\n\n    >>> np.arange(3,7)\n    array([3., 4., 5., 6.])\n\n    >>> np.arange(3,7,2)\n    array([3., 5.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.reshape",
        "results": [
          {
            "api_path": "numpy.reshape",
            "api_name": "reshape",
            "api_signature": "(a, newshape, order='C')",
            "api_description": "Changes the shape of a numset without affecting its data.",
            "api_source": [
              "@array_function_dispatch(_reshape_dispatcher)\n",
              "    return _wrapfunc(a, 'reshape', newshape, order=order)\n"
            ],
            "api_examples": "\n>>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0., 1.],\n           [2., 3.],\n           [4., 5.]])\n\n    >>> np.reshape(a, (2, 3)) # C-like index ordering\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1., 2., 3., 4., 5., 6.])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])"
          }
        ]
      }
    ]
  },
  {
    "ID": "32",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "33",
    "matches": [
      {
        "query": "numpy.min",
        "results": [
          {
            "api_path": "numpy.min",
            "api_name": "min",
            "api_signature": "(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)",
            "api_description": "Get the smallest value in a numset or the smallest value along an axis.",
            "api_source": [
              "@array_function_dispatch(_min_dispatcher)\n",
              "    return _wrapreduction(a, np.minimum, 'min', axis, None, out,\n",
              "                          keepdims=keepdims, initial=initial, where=where)\n"
            ],
            "api_examples": "\n>>> a = np.arange(4).reshape((2,2))\n    >>> a\n    array([[0., 1.],\n        [2., 3.]])\n    >>> np.min(a)           # Minimum of the flattened array\n    array(0.)\n    >>> np.min(a, axis=0)   # Minima along the first axis\n    array([0., 1.])\n    >>> np.min(a, axis=1)   # Minima along the second axis\n    array([0., 2.])\n    >>> b = np.arange(5, dtype=np.float32)\n    >>> b[2] = np.nan\n    >>> np.min(b)\n    array(0.) # nan will be ignored"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "34",
    "matches": [
      {
        "query": "numpy.linspace",
        "results": [
          {
            "api_path": "numpy.linspace",
            "api_name": "linspace",
            "api_signature": "(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0, ctx=None)",
            "api_description": "Return evenly spaced numbers over a specified interval.",
            "api_source": [
              "@array_function_dispatch(_linspace_dispatcher)\n",
              "    num = operator.index(num)\n",
              "    if num < 0:\n",
              "        raise ValueError(\"Number of samples, %s, must be non-negative.\" % num)\n",
              "    div = (num - 1) if endpoint else num\n",
              "\n",
              "    # Convert float/complex array scalars to float, gh-3504\n",
              "    # and make sure one can use variables that have an __array_interface__, gh-6634\n",
              "    start = asanyarray(start) * 1.0\n",
              "    stop  = asanyarray(stop)  * 1.0\n",
              "\n",
              "    dt = result_type(start, stop, float(num))\n",
              "    if dtype is None:\n",
              "        dtype = dt\n",
              "        integer_dtype = False\n",
              "    else:\n",
              "        integer_dtype = _nx.issubdtype(dtype, _nx.integer)\n",
              "\n",
              "    delta = stop - start\n",
              "    y = _nx.arange(0, num, dtype=dt).reshape((-1,) + (1,) * ndim(delta))\n",
              "    # In-place multiplication y *= delta/div is faster, but prevents the multiplicant\n",
              "    # from overriding what class is produced, and thus prevents, e.g. use of Quantities,\n",
              "    # see gh-7142. Hence, we multiply in place only for standard scalar types.\n",
              "    if div > 0:\n",
              "        _mult_inplace = _nx.isscalar(delta)\n",
              "        step = delta / div\n",
              "        any_step_zero = (\n",
              "            step == 0 if _mult_inplace else _nx.asanyarray(step == 0).any())\n",
              "        if any_step_zero:\n",
              "            # Special handling for denormal numbers, gh-5437\n",
              "            y /= div\n",
              "            if _mult_inplace:\n",
              "                y *= delta\n",
              "            else:\n",
              "                y = y * delta\n",
              "        else:\n",
              "            if _mult_inplace:\n",
              "                y *= step\n",
              "            else:\n",
              "                y = y * step\n",
              "    else:\n",
              "        # sequences with 0 items or 1 item with endpoint=True (i.e. div <= 0)\n",
              "        # have an undefined step\n",
              "        step = NaN\n",
              "        # Multiply with delta to allow possible override of output class.\n",
              "        y = y * delta\n",
              "\n",
              "    y += start\n",
              "\n",
              "    if endpoint and num > 1:\n"
            ],
            "api_examples": "\n>>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. , 2.2, 2.4, 2.6, 2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  , 2.25, 2.5 , 2.75, 3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1.asnumpy(), y.asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2.asnumpy(), (y + 0.5).asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "35",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "27",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "37",
    "matches": [
      {
        "query": "pandas.Series",
        "results": [
          {
            "api_path": "pandas.Series",
            "api_name": "Series",
            "api_signature": "(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False)",
            "api_description": "ndarray with axis labels in one-dimension (also time collections).",
            "api_source": [
              "class Series(base.IndexOpsMixin, NDFrame):  # type: ignore[misc]\n",
              "\n",
              "    _typ = \"series\"\n",
              "    _HANDLED_TYPES = (Index, ExtensionArray, np.ndarray)\n",
              "\n",
              "    _name: Hashable\n",
              "    _metadata: list[str] = [\"_name\"]\n",
              "    _internal_names_set = {\"index\", \"name\"} | NDFrame._internal_names_set\n",
              "    _accessors = {\"dt\", \"cat\", \"str\", \"sparse\"}\n",
              "    _hidden_attrs = (\n",
              "        base.IndexOpsMixin._hidden_attrs | NDFrame._hidden_attrs | frozenset([])\n",
              "    )\n",
              "\n",
              "    # similar to __array_priority__, positions Series after DataFrame\n",
              "    #  but before Index and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 3000\n",
              "\n",
              "    # Override cache_readonly bc Series is mutable\n",
              "    # error: Incompatible types in assignment (expression has type \"property\",\n",
              "    # base class \"IndexOpsMixin\" defined the type as \"Callable[[IndexOpsMixin], bool]\")\n",
              "    hasnans = property(  # type: ignore[assignment]\n",
              "        # error: \"Callable[[IndexOpsMixin], bool]\" has no attribute \"fget\"\n",
              "        base.IndexOpsMixin.hasnans.fget,  # type: ignore[attr-defined]\n",
              "        doc=base.IndexOpsMixin.hasnans.__doc__,\n",
              "    )\n",
              "    _mgr: SingleManager\n",
              "\n",
              "    # ----------------------------------------------------------------------\n",
              "    # Constructors\n",
              "\n",
              "    def __init__(\n",
              "        self,\n",
              "        data=None,\n",
              "        index=None,\n",
              "        dtype: Dtype | None = None,\n",
              "        name=None,\n",
              "        copy: bool | None = None,\n",
              "        fastpath: bool | lib.NoDefault = lib.no_default,\n",
              "    ) -> None:\n",
              "        if fastpath is not lib.no_default:\n",
              "            warnings.warn(\n",
              "                \"The 'fastpath' keyword in pd.Series is deprecated and will \"\n",
              "                \"be removed in a future version.\",\n",
              "                DeprecationWarning,\n",
              "                stacklevel=find_stack_level(),\n",
              "            )\n",
              "        else:\n",
              "            fastpath = False\n",
              "\n",
              "        allow_mgr = False\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.transpose",
        "results": [
          {
            "api_path": "numpy.transpose",
            "api_name": "transpose",
            "api_signature": "(a, axes=None)",
            "api_description": "Returns the changed numset after reversing or permuting the axes of a numset.",
            "api_source": [
              "@array_function_dispatch(_transpose_dispatcher)\n",
              "    return _wrapfunc(a, 'transpose', axes)\n"
            ],
            "api_examples": "\n>>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0., 1.],\n           [2., 3.]])\n    >>> np.transpose(x)\n    array([[0., 2.],\n           [1., 3.]])\n    >>> x = np.ones((1, 2, 3))\n    >>> np.transpose(x, (1, 0, 2)).shape\n    (2, 1, 3)"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "38",
    "matches": [
      {
        "query": "numpy.log",
        "results": [
          {
            "api_path": "numpy.log",
            "api_name": "log",
            "api_signature": "(x, out=None, **kwargs)",
            "api_description": "Natural logarithm, element-wise.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array([1, np.exp(1), np.exp(2), 0], dtype=np.float64)\n    >>> np.log(a)\n    array([  0.,   1.,   2., -inf], dtype=float64)\n    >>> # Using the default float32 dtype leads to slightly different behavior\n    >>> a = np.array([1, np.exp(1), np.exp(2), 0])\n    >>> np.log(a)\n    array([  0.,  0.99999994,   2., -inf])\n    >>> np.log(1)\n    0.0"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "39",
    "matches": [
      {
        "query": "numpy.linspace",
        "results": [
          {
            "api_path": "numpy.linspace",
            "api_name": "linspace",
            "api_signature": "(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0, ctx=None)",
            "api_description": "Return evenly spaced numbers over a specified interval.",
            "api_source": [
              "@array_function_dispatch(_linspace_dispatcher)\n",
              "    num = operator.index(num)\n",
              "    if num < 0:\n",
              "        raise ValueError(\"Number of samples, %s, must be non-negative.\" % num)\n",
              "    div = (num - 1) if endpoint else num\n",
              "\n",
              "    # Convert float/complex array scalars to float, gh-3504\n",
              "    # and make sure one can use variables that have an __array_interface__, gh-6634\n",
              "    start = asanyarray(start) * 1.0\n",
              "    stop  = asanyarray(stop)  * 1.0\n",
              "\n",
              "    dt = result_type(start, stop, float(num))\n",
              "    if dtype is None:\n",
              "        dtype = dt\n",
              "        integer_dtype = False\n",
              "    else:\n",
              "        integer_dtype = _nx.issubdtype(dtype, _nx.integer)\n",
              "\n",
              "    delta = stop - start\n",
              "    y = _nx.arange(0, num, dtype=dt).reshape((-1,) + (1,) * ndim(delta))\n",
              "    # In-place multiplication y *= delta/div is faster, but prevents the multiplicant\n",
              "    # from overriding what class is produced, and thus prevents, e.g. use of Quantities,\n",
              "    # see gh-7142. Hence, we multiply in place only for standard scalar types.\n",
              "    if div > 0:\n",
              "        _mult_inplace = _nx.isscalar(delta)\n",
              "        step = delta / div\n",
              "        any_step_zero = (\n",
              "            step == 0 if _mult_inplace else _nx.asanyarray(step == 0).any())\n",
              "        if any_step_zero:\n",
              "            # Special handling for denormal numbers, gh-5437\n",
              "            y /= div\n",
              "            if _mult_inplace:\n",
              "                y *= delta\n",
              "            else:\n",
              "                y = y * delta\n",
              "        else:\n",
              "            if _mult_inplace:\n",
              "                y *= step\n",
              "            else:\n",
              "                y = y * step\n",
              "    else:\n",
              "        # sequences with 0 items or 1 item with endpoint=True (i.e. div <= 0)\n",
              "        # have an undefined step\n",
              "        step = NaN\n",
              "        # Multiply with delta to allow possible override of output class.\n",
              "        y = y * delta\n",
              "\n",
              "    y += start\n",
              "\n",
              "    if endpoint and num > 1:\n"
            ],
            "api_examples": "\n>>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. , 2.2, 2.4, 2.6, 2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  , 2.25, 2.5 , 2.75, 3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1.asnumpy(), y.asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2.asnumpy(), (y + 0.5).asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "40",
    "matches": [
      {
        "query": "pandas.cut",
        "results": [
          {
            "api_path": "pandas.cut",
            "api_name": "cut",
            "api_signature": "(x, bins, right: bool = True, labels=None, retbins: bool = False, precision: int = 3, include_lowest: bool = False, duplicates: str = 'raise', ordered: bool = True)",
            "api_description": "Bin values into discrete intervals.",
            "api_source": [
              "def cut(\n",
              "    # NOTE: this binning code is changed a bit from histogram for var(x) == 0\n",
              "\n",
              "    original = x\n",
              "    x_idx = _preprocess_for_cut(x)\n",
              "    x_idx, _ = _coerce_to_type(x_idx)\n",
              "\n",
              "    if not np.iterable(bins):\n",
              "        bins = _nbins_to_bins(x_idx, bins, right)\n",
              "\n",
              "    elif isinstance(bins, IntervalIndex):\n",
              "        if bins.is_overlapping:\n",
              "            raise ValueError(\"Overlapping IntervalIndex is not accepted.\")\n",
              "\n",
              "    else:\n",
              "        bins = Index(bins)\n",
              "        if not bins.is_monotonic_increasing:\n",
              "            raise ValueError(\"bins must increase monotonically.\")\n",
              "\n",
              "    fac, bins = _bins_to_cuts(\n",
              "        x_idx,\n",
              "        bins,\n",
              "        right=right,\n",
              "        labels=labels,\n",
              "        precision=precision,\n",
              "        include_lowest=include_lowest,\n",
              "        duplicates=duplicates,\n",
              "        ordered=ordered,\n",
              "    )\n",
              "\n",
              "    return _postprocess_for_cut(fac, bins, retbins, original)\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.histogram",
        "results": [
          {
            "api_path": "numpy.histogram",
            "api_name": "histogram",
            "api_signature": "(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None)",
            "api_description": "Return a dataset's histgram object.",
            "api_source": [
              "@array_function_dispatch(_histogram_dispatcher)\n"
            ],
            "api_examples": "\n>>> np.histogram(np.arange(4), bins=np.arange(5))\n    [array([1, 1, 1, 1], dtype=int64), array([0., 1., 2., 3., 4.])]"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "41",
    "matches": [
      {
        "query": "numpy.log",
        "results": [
          {
            "api_path": "numpy.log",
            "api_name": "log",
            "api_signature": "(x, out=None, **kwargs)",
            "api_description": "Natural logarithm, element-wise.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array([1, np.exp(1), np.exp(2), 0], dtype=np.float64)\n    >>> np.log(a)\n    array([  0.,   1.,   2., -inf], dtype=float64)\n    >>> # Using the default float32 dtype leads to slightly different behavior\n    >>> a = np.array([1, np.exp(1), np.exp(2), 0])\n    >>> np.log(a)\n    array([  0.,  0.99999994,   2., -inf])\n    >>> np.log(1)\n    0.0"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "42",
    "matches": [
      {
        "query": "numpy.arange",
        "results": [
          {
            "api_path": "numpy.arange",
            "api_name": "arange",
            "api_signature": "(*args, **params)",
            "api_description": "arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.arange(3)\n    array([0., 1., 2.])\n\n    >>> np.arange(3.0)\n    array([0., 1., 2.])\n\n    >>> np.arange(3,7)\n    array([3., 4., 5., 6.])\n\n    >>> np.arange(3,7,2)\n    array([3., 5.])"
          }
        ]
      },
      {
        "query": "numpy.prod",
        "results": [
          {
            "api_path": "numpy.prod",
            "api_name": "prod",
            "api_signature": "(a, axis=None, dtype=None, out=None, keepdims=False)",
            "api_description": "Return the product of array elements over a given axis.",
            "api_source": [
              "@array_function_dispatch(_prod_dispatcher)\n",
              "    return _wrapreduction(a, np.multiply, 'prod', axis, dtype, out,\n",
              "                          keepdims=keepdims, initial=initial, where=where)\n"
            ],
            "api_examples": "\nBy default, calculate the product of all elements:\n\n    >>> np.prod(np.array([1.,2.]))\n    array(2.)\n\n    Even when the input array is two-dimensional:\n\n    >>> np.prod(np.array([1.,2.,3.,4.]).reshape((2,2)))\n    array(24.)\n\n    But we can also specify the axis over which to multiply:\n\n    >>> np.prod(np.array([1.,2.,3.,4.]).reshape((2,2)), axis=1)\n    array([  2.,  12.])\n\n    If the type of `x` is unsigned, then the output type is\n    the unsigned platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.uint8)\n    >>> np.prod(x).dtype == np.uint8\n    True\n\n    If `x` is of a signed integer type, then the output type\n    is the default platform integer:\n\n    >>> x = np.array([1, 2, 3], dtype=np.int8)\n    >>> np.prod(x).dtype == np.int8\n    True"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.reshape",
        "results": [
          {
            "api_path": "numpy.reshape",
            "api_name": "reshape",
            "api_signature": "(a, newshape, order='C')",
            "api_description": "Changes the shape of a numset without affecting its data.",
            "api_source": [
              "@array_function_dispatch(_reshape_dispatcher)\n",
              "    return _wrapfunc(a, 'reshape', newshape, order=order)\n"
            ],
            "api_examples": "\n>>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0., 1.],\n           [2., 3.],\n           [4., 5.]])\n\n    >>> np.reshape(a, (2, 3)) # C-like index ordering\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1., 2., 3., 4., 5., 6.])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])"
          }
        ]
      }
    ]
  },
  {
    "ID": "43",
    "matches": [
      {
        "query": "numpy.arange",
        "results": [
          {
            "api_path": "numpy.arange",
            "api_name": "arange",
            "api_signature": "(*args, **params)",
            "api_description": "arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.arange(3)\n    array([0., 1., 2.])\n\n    >>> np.arange(3.0)\n    array([0., 1., 2.])\n\n    >>> np.arange(3,7)\n    array([3., 4., 5., 6.])\n\n    >>> np.arange(3,7,2)\n    array([3., 5.])"
          }
        ]
      },
      {
        "query": "numpy.dot",
        "results": [
          {
            "api_path": "numpy.dot",
            "api_name": "dot",
            "api_signature": NaN,
            "api_description": "Dot product of two arrays.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array(3)\n    >>> b = np.array(4)\n    >>> np.dot(a, b)\n    array(12.)\n\n    For 2-D arrays it is the matrix product:\n\n    >>> a = np.array([[1, 0], [0, 1]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.dot(a, b)\n    array([[4., 1.],\n           [2., 2.]])\n\n    >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))\n    >>> b = np.arange(5*6)[::-1].reshape((6,5))\n    >>> np.dot(a, b)[2,3,2,2]\n    array(29884.)\n    >>> np.sum(a[2,3,2,:] * b[:,2])\n    array(29884.)"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.reshape",
        "results": [
          {
            "api_path": "numpy.reshape",
            "api_name": "reshape",
            "api_signature": "(a, newshape, order='C')",
            "api_description": "Changes the shape of a numset without affecting its data.",
            "api_source": [
              "@array_function_dispatch(_reshape_dispatcher)\n",
              "    return _wrapfunc(a, 'reshape', newshape, order=order)\n"
            ],
            "api_examples": "\n>>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0., 1.],\n           [2., 3.],\n           [4., 5.]])\n\n    >>> np.reshape(a, (2, 3)) # C-like index ordering\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape\n    array([[0., 1., 2.],\n           [3., 4., 5.]])\n\n    >>> a = np.array([[1,2,3], [4,5,6]])\n    >>> np.reshape(a, 6)\n    array([1., 2., 3., 4., 5., 6.])\n\n    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])"
          }
        ]
      }
    ]
  },
  {
    "ID": "44",
    "matches": [
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "45",
    "matches": [
      {
        "query": "numpy.histogram",
        "results": [
          {
            "api_path": "numpy.histogram",
            "api_name": "histogram",
            "api_signature": "(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None)",
            "api_description": "Return a dataset's histgram object.",
            "api_source": [
              "@array_function_dispatch(_histogram_dispatcher)\n"
            ],
            "api_examples": "\n>>> np.histogram(np.arange(4), bins=np.arange(5))\n    [array([1, 1, 1, 1], dtype=int64), array([0., 1., 2., 3., 4.])]"
          }
        ]
      },
      {
        "query": "numpy.linspace",
        "results": [
          {
            "api_path": "numpy.linspace",
            "api_name": "linspace",
            "api_signature": "(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0, ctx=None)",
            "api_description": "Return evenly spaced numbers over a specified interval.",
            "api_source": [
              "@array_function_dispatch(_linspace_dispatcher)\n",
              "    num = operator.index(num)\n",
              "    if num < 0:\n",
              "        raise ValueError(\"Number of samples, %s, must be non-negative.\" % num)\n",
              "    div = (num - 1) if endpoint else num\n",
              "\n",
              "    # Convert float/complex array scalars to float, gh-3504\n",
              "    # and make sure one can use variables that have an __array_interface__, gh-6634\n",
              "    start = asanyarray(start) * 1.0\n",
              "    stop  = asanyarray(stop)  * 1.0\n",
              "\n",
              "    dt = result_type(start, stop, float(num))\n",
              "    if dtype is None:\n",
              "        dtype = dt\n",
              "        integer_dtype = False\n",
              "    else:\n",
              "        integer_dtype = _nx.issubdtype(dtype, _nx.integer)\n",
              "\n",
              "    delta = stop - start\n",
              "    y = _nx.arange(0, num, dtype=dt).reshape((-1,) + (1,) * ndim(delta))\n",
              "    # In-place multiplication y *= delta/div is faster, but prevents the multiplicant\n",
              "    # from overriding what class is produced, and thus prevents, e.g. use of Quantities,\n",
              "    # see gh-7142. Hence, we multiply in place only for standard scalar types.\n",
              "    if div > 0:\n",
              "        _mult_inplace = _nx.isscalar(delta)\n",
              "        step = delta / div\n",
              "        any_step_zero = (\n",
              "            step == 0 if _mult_inplace else _nx.asanyarray(step == 0).any())\n",
              "        if any_step_zero:\n",
              "            # Special handling for denormal numbers, gh-5437\n",
              "            y /= div\n",
              "            if _mult_inplace:\n",
              "                y *= delta\n",
              "            else:\n",
              "                y = y * delta\n",
              "        else:\n",
              "            if _mult_inplace:\n",
              "                y *= step\n",
              "            else:\n",
              "                y = y * step\n",
              "    else:\n",
              "        # sequences with 0 items or 1 item with endpoint=True (i.e. div <= 0)\n",
              "        # have an undefined step\n",
              "        step = NaN\n",
              "        # Multiply with delta to allow possible override of output class.\n",
              "        y = y * delta\n",
              "\n",
              "    y += start\n",
              "\n",
              "    if endpoint and num > 1:\n"
            ],
            "api_examples": "\n>>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. , 2.2, 2.4, 2.6, 2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  , 2.25, 2.5 , 2.75, 3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1.asnumpy(), y.asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2.asnumpy(), (y + 0.5).asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "46",
    "matches": [
      {
        "query": "numpy.linspace",
        "results": [
          {
            "api_path": "numpy.linspace",
            "api_name": "linspace",
            "api_signature": "(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0, ctx=None)",
            "api_description": "Return evenly spaced numbers over a specified interval.",
            "api_source": [
              "@array_function_dispatch(_linspace_dispatcher)\n",
              "    num = operator.index(num)\n",
              "    if num < 0:\n",
              "        raise ValueError(\"Number of samples, %s, must be non-negative.\" % num)\n",
              "    div = (num - 1) if endpoint else num\n",
              "\n",
              "    # Convert float/complex array scalars to float, gh-3504\n",
              "    # and make sure one can use variables that have an __array_interface__, gh-6634\n",
              "    start = asanyarray(start) * 1.0\n",
              "    stop  = asanyarray(stop)  * 1.0\n",
              "\n",
              "    dt = result_type(start, stop, float(num))\n",
              "    if dtype is None:\n",
              "        dtype = dt\n",
              "        integer_dtype = False\n",
              "    else:\n",
              "        integer_dtype = _nx.issubdtype(dtype, _nx.integer)\n",
              "\n",
              "    delta = stop - start\n",
              "    y = _nx.arange(0, num, dtype=dt).reshape((-1,) + (1,) * ndim(delta))\n",
              "    # In-place multiplication y *= delta/div is faster, but prevents the multiplicant\n",
              "    # from overriding what class is produced, and thus prevents, e.g. use of Quantities,\n",
              "    # see gh-7142. Hence, we multiply in place only for standard scalar types.\n",
              "    if div > 0:\n",
              "        _mult_inplace = _nx.isscalar(delta)\n",
              "        step = delta / div\n",
              "        any_step_zero = (\n",
              "            step == 0 if _mult_inplace else _nx.asanyarray(step == 0).any())\n",
              "        if any_step_zero:\n",
              "            # Special handling for denormal numbers, gh-5437\n",
              "            y /= div\n",
              "            if _mult_inplace:\n",
              "                y *= delta\n",
              "            else:\n",
              "                y = y * delta\n",
              "        else:\n",
              "            if _mult_inplace:\n",
              "                y *= step\n",
              "            else:\n",
              "                y = y * step\n",
              "    else:\n",
              "        # sequences with 0 items or 1 item with endpoint=True (i.e. div <= 0)\n",
              "        # have an undefined step\n",
              "        step = NaN\n",
              "        # Multiply with delta to allow possible override of output class.\n",
              "        y = y * delta\n",
              "\n",
              "    y += start\n",
              "\n",
              "    if endpoint and num > 1:\n"
            ],
            "api_examples": "\n>>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. , 2.2, 2.4, 2.6, 2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  , 2.25, 2.5 , 2.75, 3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1.asnumpy(), y.asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2.asnumpy(), (y + 0.5).asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      },
      {
        "query": "numpy.histogram",
        "results": [
          {
            "api_path": "numpy.histogram",
            "api_name": "histogram",
            "api_signature": "(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None)",
            "api_description": "Return a dataset's histgram object.",
            "api_source": [
              "@array_function_dispatch(_histogram_dispatcher)\n"
            ],
            "api_examples": "\n>>> np.histogram(np.arange(4), bins=np.arange(5))\n    [array([1, 1, 1, 1], dtype=int64), array([0., 1., 2., 3., 4.])]"
          }
        ]
      }
    ]
  },
  {
    "ID": "47",
    "matches": [
      {
        "query": "numpy.transpose",
        "results": [
          {
            "api_path": "numpy.transpose",
            "api_name": "transpose",
            "api_signature": "(a, axes=None)",
            "api_description": "Returns the changed numset after reversing or permuting the axes of a numset.",
            "api_source": [
              "@array_function_dispatch(_transpose_dispatcher)\n",
              "    return _wrapfunc(a, 'transpose', axes)\n"
            ],
            "api_examples": "\n>>> x = np.arange(4).reshape((2,2))\n    >>> x\n    array([[0., 1.],\n           [2., 3.]])\n    >>> np.transpose(x)\n    array([[0., 2.],\n           [1., 3.]])\n    >>> x = np.ones((1, 2, 3))\n    >>> np.transpose(x, (1, 0, 2)).shape\n    (2, 1, 3)"
          }
        ]
      },
      {
        "query": "numpy.zeros",
        "results": [
          {
            "api_path": "numpy.zeros",
            "api_name": "zeros",
            "api_signature": "(shape, dtype=None, order='C', ctx=None)",
            "api_description": "Return a new array of given shape and type, filled with zeros.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.zeros(5)\n    array([0., 0., 0., 0., 0.])\n\n    >>> np.zeros((5,), dtype=int)\n    array([0, 0, 0, 0, 0], dtype=int64)\n\n    >>> np.zeros((2, 1))\n    array([[0.],\n           [0.]])"
          }
        ]
      },
      {
        "query": "numpy.ones",
        "results": [
          {
            "api_path": "numpy.ones",
            "api_name": "ones",
            "api_signature": "(shape, dtype=None, order='C', *, like=None)",
            "api_description": "Create a new numset  of specified shape and type and fill it with ones.",
            "api_source": [
              "@set_array_function_like_doc\n",
              "    if like is not None:\n",
              "        return _ones_with_like(like, shape, dtype=dtype, order=order)\n",
              "\n",
              "    a = empty(shape, dtype, order)\n",
              "    multiarray.copyto(a, 1, casting='unsafe')\n",
              "    return a\n"
            ],
            "api_examples": "\n>>> np.ones(5)\n    array([1., 1., 1., 1., 1.])\n\n    >>> np.ones((5,), dtype=int)\n    array([1, 1, 1, 1, 1], dtype=int64)\n\n    >>> np.ones((2, 1))\n    array([[1.],\n           [1.]])\n\n    >>> s = (2,2)\n    >>> np.ones(s)\n    array([[1., 1.],\n           [1., 1.]])"
          }
        ]
      },
      {
        "query": "numpy.concatenate",
        "results": [
          {
            "api_path": "numpy.concatenate",
            "api_name": "concatenate",
            "api_signature": "(numsets, axis=0)",
            "api_description": "Return a numset concatenated with given numsets along the specified axis.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array([[1, 2], [3, 4]])\n    >>> b = np.array([[5, 6]])\n    >>> np.concatenate((a, b), axis=0)\n    array([[1., 2.],\n           [3., 4.],\n           [5., 6.]])\n\n    >>> np.concatenate((a, b.T), axis=1)\n    array([[1., 2., 5.],\n           [3., 4., 6.]])\n\n    >>> np.concatenate((a, b), axis=None)\n    array([1., 2., 3., 4., 5., 6.])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "48",
    "matches": [
      {
        "query": "numpy.multiply",
        "results": [
          {
            "api_path": "numpy.multiply",
            "api_name": "multiply",
            "api_signature": "(x1, x2, out=None, **kwargs)",
            "api_description": "Multiply arguments element-wise.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.multiply(2.0, 4.0)\n    8.0\n    >>> x1 = np.arange(9.0).reshape((3, 3))\n    >>> x2 = np.arange(3.0)\n    >>> np.multiply(x1, x2)\n    array([[ 0.,  1.,  4.],\n           [ 0.,  4., 10.],\n           [ 0.,  7., 16.]])"
          }
        ]
      },
      {
        "query": "numpy.add",
        "results": [
          {
            "api_path": "numpy.add",
            "api_name": "add",
            "api_signature": "(x1, x2)",
            "api_description": "Return the two numsets' element-wise string or unicode concatenation.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.add(1.0, 4.0)\n    5.0\n    >>>\n    >>> x1 = np.arange(9.0).reshape((3, 3))\n    >>> x2 = np.arange(3.0)\n    >>> np.add(x1, x2)\n    array([[ 0.,  2.,  4.],\n           [ 3.,  5.,  7.],\n           [ 6.,  8., 10.]])"
          }
        ]
      },
      {
        "query": "numpy.dot",
        "results": [
          {
            "api_path": "numpy.dot",
            "api_name": "dot",
            "api_signature": NaN,
            "api_description": "Dot product of two arrays.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> a = np.array(3)\n    >>> b = np.array(4)\n    >>> np.dot(a, b)\n    array(12.)\n\n    For 2-D arrays it is the matrix product:\n\n    >>> a = np.array([[1, 0], [0, 1]])\n    >>> b = np.array([[4, 1], [2, 2]])\n    >>> np.dot(a, b)\n    array([[4., 1.],\n           [2., 2.]])\n\n    >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))\n    >>> b = np.arange(5*6)[::-1].reshape((6,5))\n    >>> np.dot(a, b)[2,3,2,2]\n    array(29884.)\n    >>> np.sum(a[2,3,2,:] * b[:,2])\n    array(29884.)"
          }
        ]
      },
      {
        "query": "numpy.linspace",
        "results": [
          {
            "api_path": "numpy.linspace",
            "api_name": "linspace",
            "api_signature": "(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0, ctx=None)",
            "api_description": "Return evenly spaced numbers over a specified interval.",
            "api_source": [
              "@array_function_dispatch(_linspace_dispatcher)\n",
              "    num = operator.index(num)\n",
              "    if num < 0:\n",
              "        raise ValueError(\"Number of samples, %s, must be non-negative.\" % num)\n",
              "    div = (num - 1) if endpoint else num\n",
              "\n",
              "    # Convert float/complex array scalars to float, gh-3504\n",
              "    # and make sure one can use variables that have an __array_interface__, gh-6634\n",
              "    start = asanyarray(start) * 1.0\n",
              "    stop  = asanyarray(stop)  * 1.0\n",
              "\n",
              "    dt = result_type(start, stop, float(num))\n",
              "    if dtype is None:\n",
              "        dtype = dt\n",
              "        integer_dtype = False\n",
              "    else:\n",
              "        integer_dtype = _nx.issubdtype(dtype, _nx.integer)\n",
              "\n",
              "    delta = stop - start\n",
              "    y = _nx.arange(0, num, dtype=dt).reshape((-1,) + (1,) * ndim(delta))\n",
              "    # In-place multiplication y *= delta/div is faster, but prevents the multiplicant\n",
              "    # from overriding what class is produced, and thus prevents, e.g. use of Quantities,\n",
              "    # see gh-7142. Hence, we multiply in place only for standard scalar types.\n",
              "    if div > 0:\n",
              "        _mult_inplace = _nx.isscalar(delta)\n",
              "        step = delta / div\n",
              "        any_step_zero = (\n",
              "            step == 0 if _mult_inplace else _nx.asanyarray(step == 0).any())\n",
              "        if any_step_zero:\n",
              "            # Special handling for denormal numbers, gh-5437\n",
              "            y /= div\n",
              "            if _mult_inplace:\n",
              "                y *= delta\n",
              "            else:\n",
              "                y = y * delta\n",
              "        else:\n",
              "            if _mult_inplace:\n",
              "                y *= step\n",
              "            else:\n",
              "                y = y * step\n",
              "    else:\n",
              "        # sequences with 0 items or 1 item with endpoint=True (i.e. div <= 0)\n",
              "        # have an undefined step\n",
              "        step = NaN\n",
              "        # Multiply with delta to allow possible override of output class.\n",
              "        y = y * delta\n",
              "\n",
              "    y += start\n",
              "\n",
              "    if endpoint and num > 1:\n"
            ],
            "api_examples": "\n>>> np.linspace(2.0, 3.0, num=5)\n    array([2.  , 2.25, 2.5 , 2.75, 3.  ])\n    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)\n    array([2. , 2.2, 2.4, 2.6, 2.8])\n    >>> np.linspace(2.0, 3.0, num=5, retstep=True)\n    (array([2.  , 2.25, 2.5 , 2.75, 3.  ]), 0.25)\n\n    Graphical illustration:\n\n    >>> import matplotlib.pyplot as plt\n    >>> N = 8\n    >>> y = np.zeros(N)\n    >>> x1 = np.linspace(0, 10, N, endpoint=True)\n    >>> x2 = np.linspace(0, 10, N, endpoint=False)\n    >>> plt.plot(x1.asnumpy(), y.asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.plot(x2.asnumpy(), (y + 0.5).asnumpy(), 'o')\n    [<matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.ylim([-0.5, 1])\n    (-0.5, 1)\n    >>> plt.show()"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  },
  {
    "ID": "49",
    "matches": [
      {
        "query": "numpy.vstack",
        "results": [
          {
            "api_path": "numpy.vstack",
            "api_name": "vstack",
            "api_signature": "(tup)",
            "api_description": "Stack numsets in vertical or row wise order.",
            "api_source": [
              "@array_function_dispatch(_vhstack_dispatcher)\n",
              "    arrs = atleast_2d(*tup)\n",
              "    if not isinstance(arrs, list):\n",
              "        arrs = [arrs]\n",
              "    return _nx.concatenate(arrs, 0, dtype=dtype, casting=casting)\n"
            ],
            "api_examples": "\n>>> a = np.array([1, 2, 3])\n    >>> b = np.array([2, 3, 4])\n    >>> np.vstack((a, b))\n    array([[1., 2., 3.],\n           [2., 3., 4.]])\n\n    >>> a = np.array([[1], [2], [3]])\n    >>> b = np.array([[2], [3], [4]])\n    >>> np.vstack((a, b))\n    array([[1.],\n           [2.],\n           [3.],\n           [2.],\n           [3.],\n           [4.]])"
          }
        ]
      },
      {
        "query": "numpy.zeros",
        "results": [
          {
            "api_path": "numpy.zeros",
            "api_name": "zeros",
            "api_signature": "(shape, dtype=None, order='C', ctx=None)",
            "api_description": "Return a new array of given shape and type, filled with zeros.",
            "api_source": [
              "source_unavailable"
            ],
            "api_examples": "\n>>> np.zeros(5)\n    array([0., 0., 0., 0., 0.])\n\n    >>> np.zeros((5,), dtype=int)\n    array([0, 0, 0, 0, 0], dtype=int64)\n\n    >>> np.zeros((2, 1))\n    array([[0.],\n           [0.]])"
          }
        ]
      },
      {
        "query": "pandas.DataFrame",
        "results": [
          {
            "api_path": "pandas.DataFrame",
            "api_name": "DataFrame",
            "api_signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None)",
            "api_description": "Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
            "api_source": [
              "class DataFrame(NDFrame, OpsMixin):\n",
              "\n",
              "    _internal_names_set = {\"columns\", \"index\"} | NDFrame._internal_names_set\n",
              "    _typ = \"dataframe\"\n",
              "    _HANDLED_TYPES = (Series, Index, ExtensionArray, np.ndarray)\n",
              "    _accessors: set[str] = {\"sparse\"}\n",
              "    _hidden_attrs: frozenset[str] = NDFrame._hidden_attrs | frozenset([])\n",
              "    _mgr: BlockManager | ArrayManager\n",
              "\n",
              "    # similar to __array_priority__, positions DataFrame before Series, Index,\n",
              "    #  and ExtensionArray.  Should NOT be overridden by subclasses.\n",
              "    __pandas_priority__ = 4000\n",
              "\n",
              "    @property\n",
              "    def _constructor(self) -> Callable[..., DataFrame]:\n",
              "        return DataFrame\n",
              "\n",
              "    def _constructor_from_mgr(self, mgr, axes) -> DataFrame:\n",
              "        df = DataFrame._from_mgr(mgr, axes=axes)\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor is DataFrame`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return df\n",
              "\n",
              "        elif type(self).__name__ == \"GeoDataFrame\":\n",
              "            # Shim until geopandas can override their _constructor_from_mgr\n",
              "            #  bc they have different behavior for Managers than for DataFrames\n",
              "            return self._constructor(mgr)\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.DataFrame object.\n",
              "        return self._constructor(df)\n",
              "\n",
              "    _constructor_sliced: Callable[..., Series] = Series\n",
              "\n",
              "    def _constructor_sliced_from_mgr(self, mgr, axes) -> Series:\n",
              "        ser = Series._from_mgr(mgr, axes)\n",
              "        ser._name = None  # caller is responsible for setting real name\n",
              "\n",
              "        if type(self) is DataFrame:\n",
              "            # This would also work `if self._constructor_sliced is Series`, but\n",
              "            #  this check is slightly faster, benefiting the most-common case.\n",
              "            return ser\n",
              "\n",
              "        # We assume that the subclass __init__ knows how to handle a\n",
              "        #  pd.Series object.\n",
              "        return self._constructor_sliced(ser)\n",
              "\n",
              "    # ----------------------------------------------------------------------\n"
            ],
            "api_examples": NaN
          }
        ]
      }
    ]
  }
]